1. Что требуется для определения типа данных?

2. Почему обход связного списка, приведенного в листинге 17.2, может осуществляться только в одном направлении? Как можно было бы изменить определение struct film, чтобы обход списка стал возможен в обоих направлениях?

3. Что такое ADT?

4. Функция QueueIsEpty() принимает в качестве аргумента указатель на структуру queue, но ее можно было бы написать так, чтобы она принимала саму структуру queue, а не указатель на нее. Каковы преимущества и недостатки каждого из этих подходов?

5. Стек является еще одной формой данных из семейства списков. В стеке добавления и удаления могут выполняться только с одной стороны списка. Говорят, что элементы “заталкиваются” в стек и “выталкиваются” из него. Следовательно, стек представляет собой структуру LIFO(first in, first out — “последним прибыл, первым обслужен”).
	
	а. О пределите тип ADT для стека.

	б. Определите программный интерфейс стека, т.е. заголовочный файл stack.h.

6. Каково максимальное количество сравнений, которые требуются при последовательном поиске и двоичном поиске для определения того, что конкретный элемент отсутствует в упорядоченном списке из 3 элементов? В списке из 1023 элементов? В списке из 65 535 элементов?

7. Предположим, что программа создает двоичное дерево поиска слов с использованием алгоритма, описанного в этой главе. Нарисуйте дерево, исходя из предположения, что слова были введены в следующем порядке:

	а. nice food roam dodge gate office wave
	б. wave roam office nice gate food dodge
	в. food dodge rоаm wave office gate nice
	г. nice roam office food wave gate dodge

8. Взгляните на двоичные деревья, созданные при ответе на вопрос для самоконтроля под номером 7. Как они будут выглядеть после удаления из них слова food с помощью алгоритма, описанного в этой главе?


